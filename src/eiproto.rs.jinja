{# ei-scanner jinja template, for `` #}

// GENERATED FILE

// Define module for each interface?
// TODO Cleaner/safer way to strip out Ei/Eis prefix?
// TODO Something like WEnum? Or assume unfamiliar variant won't exist in known version?

{# TODO handle destructor #}

{% macro interface_type(interface) -%}
    super::{{interface.plainname}}::{{interface.plainname|camel}}
{%- endmacro %}

{% macro arg_type(arg, owned) -%}
    {% if arg.enum != None %} {{ arg.enum.name|camel }}
    {% elif arg.protocol_type == 'string' and owned %} String
    {% elif arg.protocol_type == 'string' %} &str
    {% elif arg.protocol_type == 'int32' %} i32
    {% elif arg.protocol_type == 'uint32' %} u32
    {% elif arg.protocol_type == 'int64' %} i64
    {% elif arg.protocol_type == 'uint64' %} u64
    {% elif arg.protocol_type == 'object' and owned %} {{interface_type(arg.interface)}}
    {% elif arg.protocol_type == 'object' %} &{{interface_type(arg.interface)}}
    {% elif arg.protocol_type == 'new_id' and arg.interface %} {{interface_type(arg.interface)}} {# TODO #}
    {% elif arg.protocol_type == 'new_id' %} u64 {# TODO interface arg? #}
    {% elif arg.protocol_type == 'float' %} f32
    {% elif arg.protocol_type == 'fd' and owned %} std::os::unix::io::OwnedFd
    {% elif arg.protocol_type == 'fd' %} std::os::unix::io::BorrowedFd
    {% else %} unhandled_arg_type_{{arg.protocol_type}}
    {% endif %}
{%- endmacro %}

{% macro return_type(arguments) -%}
{%- endmacro %}

{% macro incoming_enum(interface) -%}
    {% if interface.name.startswith('eis_') %}
    Request
    {% else %}
    Event
    {% endif %}
{%- endmacro %}

{% for interface in interfaces %}
/** {{interface.description.text|ei_escape_names}} */
pub mod {{interface.plainname}} {
    #[derive(Clone, Debug)]
    pub struct {{interface.plainname|camel}}(pub(crate) crate::Object);

    impl crate::Interface for {{interface.plainname|camel}} {
        const NAME: &'static str = "{{interface.protocol_name}}";
        const VERSION: u32 = {{interface.version}};
        type Incoming = {{incoming_enum(interface)}};
    }

    {# TODO validate that ID is valid? #}
    impl crate::OwnedArg for {{interface.plainname|camel}} {
        fn parse(buf: &mut crate::ByteStream) -> Option<Self> {
            let id = u64::parse(buf)?;
            Some(Self(crate::Object::new(buf.connection().clone(), id)))
        }
    }

    impl {{interface.plainname|camel}} {
        {% for outgoing in interface.outgoing %}
        /** {{outgoing.description.text|ei_escape_names}} */
        pub fn {{outgoing.name}}(
            &self,
            {%- for arg in outgoing.arguments %}
            {% if arg.protocol_type != 'new_id' %}
            {{arg.name}}: {{arg_type(arg, false)}},
            {% endif %}
            {% endfor -%}
            ) -> rustix::io::Result<(
            {%- for arg in outgoing.arguments %}
            {% if arg.protocol_type == 'new_id' %}
            {{arg_type(arg, true)}}
            {% endif %}
            {% endfor -%}
            )>{
            {%- for arg in outgoing.arguments %}
            {% if arg.protocol_type == 'new_id' %}
            let {{arg.name}} = self.0.connection().new_id("{{arg.interface.protocol_name or ''}}");
            {% endif -%}
            {% endfor -%}

            let args = &[
            {%- for arg in outgoing.arguments %}
                crate::Arg::{{arg.protocol_type|camel}}({{arg.name}}.into()),
            {% endfor -%}
            ];

            self.0.request({{outgoing.opcode}}, args)?;
            {% if outgoing.is_destructor %}
                self.0.connection().remove_id(self.0.id());
            {% endif %}

            Ok((
            {%- for arg in outgoing.arguments %}
            {% if arg.protocol_type == 'new_id' %}
            {% if arg.interface %}
                {{arg_type(arg, true)}}(crate::Object::new(self.0.connection().clone(), {{arg.name}}))
            {% else -%}
            {{arg.name}} {# TODO how to handle type that's not statically known? #}
            {% endif -%}
            {% endif -%}
            {% endfor -%}
            ))
        }

        {% endfor %}
    }

    {% for enum in interface.enums %}
     /** {{enum.description.text|ei_escape_names}} */
    #[derive(Clone, Copy, Debug)]
    pub enum {{enum.camel_name}} {
        {% for entry in enum.entries %}
        /** {{entry.summary}} */
        {{entry.name|camel}} = {{entry.value}},
        {% endfor %}
    }

    impl From<{{enum.camel_name}}> for u32 {
        fn from(value: {{enum.camel_name}}) -> u32 {
            value as u32
        }
    }

    impl crate::OwnedArg for {{enum.camel_name}} {
        fn parse(buf: &mut crate::ByteStream) -> Option<Self> {
            match u32::parse(buf)? {
            {% for entry in enum.entries %}
                {{entry.value}} => Some(Self::{{entry.name|camel}}),
            {% endfor %}
                _ => None
            }
        }
    }
    {% endfor %}

    #[non_exhaustive]
    #[derive(Debug)]
    pub enum {{incoming_enum(interface)}} {
        {% for incoming in interface.incoming %}
            /** {{incoming.description.text|ei_escape_names}} */
            {{ incoming.name|camel }}
                {% if incoming.arguments %}
                { {% for arg in incoming.arguments %}
                    /** {{arg.summary}} */
                    {{arg.name}}: {{arg_type(arg, true)}},
                {% endfor %} }
                {% endif %},
        {% endfor %}
    }

    impl {{incoming_enum(interface)}} {
        {# TODO fds; assume bytes read is total? #}
        pub(super) fn parse(operand: u32, bytes: &mut crate::ByteStream) -> Option<Self> {
            match operand {
            {% for incoming in interface.incoming %}
                {{incoming.opcode}} =>
                Some(Self::{{ incoming.name|camel }}
                {% if incoming.arguments %} {
                {% for arg in incoming.arguments %}
                    {{arg.name}}: bytes.read_arg()?,
                {% endfor %} }
                {% endif %} ),
            {% endfor %}
                _ => None
            }
        }
    }
}

{% endfor %}

// map opcodes

#[non_exhaustive]
#[derive(Debug)]
pub enum {{incoming_enum(interfaces[0])}} {
    {% for interface in interfaces %}
        {{interface.plainname|camel}}({{interface.plainname}}::{{incoming_enum(interface)}}),
    {% endfor %}
}

impl {{incoming_enum(interfaces[0])}} {
    // TODO pub
    // TODO: pass object along with event?
    pub fn parse(interface: &'static str, operand: u32, bytes: &mut crate::ByteStream) -> Option<Self> {
        match interface {
            {% for interface in interfaces %}
            "{{interface.protocol_name}}" => Some(Self::{{interface.plainname|camel}}({{interface.plainname}}::{{incoming_enum(interface)}}::parse(operand, bytes)?)),
            {% endfor %}
            _=> None,
        }
    }
}
